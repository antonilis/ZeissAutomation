<?xml version="1.0" encoding="utf-8"?>
<Script>
  <Context>Zen26</Context>
  <Version>1.0</Version>
  <Language>Python</Language>
  <Text>
import json
import time
import uuid
from System.IO import Directory, Path, File

from execute_python import PythonAnalysisRunner
from path_manager_main_macro import PathManager


# Function for logging

def log(msg):
    """
    Function for printing the logs to the txt file
    :param str msg: log to be printed
    :return: None
    """
    path = "D:\\zeiss\\Desktop\\zen_log.txt"
    with open(path, "a") as f:
        f.write(msg + "\n")


CONFIG_PATH = r"D:\zeiss\Desktop\automation\config\path_config.json"  # JSON with basic path configuration for the software
PROCESSING_PATH = r"D:\zeiss\Desktop\automation\config\preprocessing_config.json"  # JSON with the arguments for the image analysis


###################### class for API calls ###########################################################
class ZeissApiProcessor:
    """
    Class which collects all of the main API calls to controll the microscope
    """

    @staticmethod
    def read_json(path):
        with open(path, "r") as file:
            data = json.load(file)

        return data

    @staticmethod
    def get_stage_focus_position():
        """
         Return current stage (X, Y) and focus (Z) positions as [x,y,z] list.
         """
        x = Zen.Devices.Stage.ActualPositionX
        y = Zen.Devices.Stage.ActualPositionY
        z = Zen.Devices.Focus.ActualPosition

        return [x, y, z]

    @staticmethod
    def move(points_to_move):
        """
        Move stage and focus to the given [X, Y, Z] coordinates.
        """
        Zen.Devices.Stage.MoveTo(points_to_move[0], points_to_move[1])
        Zen.Devices.Focus.MoveTo(points_to_move[2])

    @staticmethod
    def load_experiment(chosen_experiment):
        """
         Load and activate an experiment (.czexp file) by name.
         """
        exp = Zen.Acquisition.Experiments.GetByName(chosen_experiment)
        exp.SetActive()
        time.sleep(2)  # Rest for hardware adjustment
        log("Loaded experiment {}".format(chosen_experiment))

    @staticmethod
    def execute_current_experiment():
        """
        Execute the currently active experiment.
        """
        Zen.Acquisition.Execute(Zen.Acquisition.Experiments.ActiveExperiment)
        time.sleep(2)  # Rest for hardware adjustment

    @staticmethod
    def save_experiment_result(name, base_name=None):
        """
        Saves the results of the experiments in the results folder. For the .czi files it utilizes the API call, but for .fcs and .raw files
        it moves them from autosave folder.
        """
        document = Zen.Application.Documents.ActiveDocument

        if document is not None:  # The document is None for the .fcs experiments
            document.Save(name)
        else:
            files = PathManager(CONFIG_PATH).get_latest_fcs_and_raws()

            log(str(files))

            for file in files:
                file_name = Path.GetFileNameWithoutExtension(file)
                extenion = Path.GetExtension(file)

                parts = file_name.split("_")

                if len(parts) > 1:

                    final_name = "{}_{}{}".format(base_name, "_".join(parts[1:]), extenion)

                else:

                    final_name = "{}{}".format(base_name, extenion)

                File.Move(file, Path.Combine(name, final_name))


# ==============================================================================
# PIPELINE CLASS
# ==============================================================================

class AcquisitionPipeline:
    """
    A comprehensive pipeline encompassing object detection, motion control toward the detected objects,
    visualization, and post-processing steps involving reanalysis of spatial coordinates (XY and Z)
    and quantitative measurements of the identified objects.
    """

    CONFIG_PATH = r"D:\zeiss\Desktop\automation\config\path_config.json"

    def __init__(self,
                 object_visualization_experiment=None,
                 reanalysis_dict=None,
                 post_reanalysis_experiments=None, adaptive_experiment=None):

        # arguments collecting the experiments names and arguments for Python analysis, which will be used at different
        # stages of the pipeline
        self.object_visualization_experiment = object_visualization_experiment
        self.reanalysis_dict = reanalysis_dict
        self.post_reanalysis_experiments = post_reanalysis_experiments or []
        self.adaptive_experiment = adaptive_experiment

        # Initializing objects for the directories management for reading/saving the results and for initializing python
        # with the arguments
        self.path_manager = PathManager(self.CONFIG_PATH)
        self.python_analysis_runner = PythonAnalysisRunner(self.CONFIG_PATH)


        self.points_for_overview = self.get_overview_points() # points on which the pipeline will be executed
        self.overview_id = str(uuid.uuid4())
        self.measurements_objects = {}

    def get_overview_points(self):
        """
        Reads the points in which the full pipeline needs to be executed.
        """
        points_path = Path.Combine(self.path_manager.measurements, "points_for_overview.json")

        if File.Exists(points_path):

            points_for_overview = ZeissApiProcessor.read_json(points_path)
        else:

            points_for_overview = None

        return points_for_overview


    def acquire_overview(self, overview_experiment, analysis_args=None, name=None):

        """
        Method for loading, executing and saving the overview experiment. Activating the analysis of the results and
        reading the JSON with positions of the objects for the measurement from Python analysis.
        """

        log('Initializing overview experiment')

        ZeissApiProcessor.load_experiment(overview_experiment)
        ZeissApiProcessor.execute_current_experiment()

        # The name of the overview image is the combination of pipeline overview id and the name of the point in which
        # the pipeline is executed
        overview_file_name = self.path_manager.overview_image_path(self.overview_id, name)
        overview_analysis_path = self.path_manager.temp_file_path(self.overview_id, None, name)

        ZeissApiProcessor.save_experiment_result(overview_file_name)

        log('Overview experiment finished')

        if analysis_args:
            args_overview = {'type': 'overview', 'file_path': overview_file_name,
                             'saving_path': overview_analysis_path, 'analysis_arguments': analysis_args,
                             'is_FCS': False}

            log("Initializing the overview image analysis: {}".format(args_overview))
            self.python_analysis_runner.run(**args_overview)

            # Loading JSON with the objects positions, crucial for the capture_objects method
            self.measurements_objects = self.load_measurements(self.overview_id, name=name)

        log("Overview finished")

    def load_measurements(self, obj_id, reanalysis_type=None, name=None):
        """
        Loads JSON files for the reanalysis of the objects positions.
        """
        points_path = self.path_manager.temp_file_path(obj_id, reanalysis_type, name)

        data = ZeissApiProcessor.read_json(points_path)
        log("Loaded measurement data for object {} [{}] from {}".format(
            obj_id, reanalysis_type or "overview", points_path))

        return data

    def capture_objects(self, object_ids=None, name=None):
        """
        Method for performing objects visualizationexperiment, calling functions for reanalysis of xy and z position and
        executing all the post reanalysis experiments on all of founded objects in the pipeline
        :param object_ids: uuids of the founded objects in the current pipeline position
        :param name: Name of the position in which the pipeline will be executed
        :return: None
        """

        if not self.measurements_objects:
            log("No overview results for {}".format(self.overview_id))
            return

        if object_ids is None:
            object_ids = list(self.measurements_objects.keys())

        log("Initialized capturing objects")

        for obj_id in object_ids:
            obj = self.measurements_objects[obj_id]
            ZeissApiProcessor.move(obj["position"])

            # --- 1ï¸ Do object visualization experiment, which results are used for xy-reanalysis ---
            self._run_experiment(obj_id, self.object_visualization_experiment, stage='_exp', name=name, obj=obj)

            log('Finished visualization of object {}'.format(obj_id))

            # --- 2 Reanalysis ---
            if self.reanalysis_dict is not None:
                log("Initialized reanalysis of object: {}".format(obj_id))

                # Reanalysis XY
                if self.reanalysis_dict.get('xy'):
                    self._perform_reanalysis_xy(obj_id, name)

                # Reanalysis Z
                z_data = self.reanalysis_dict.get('z')
                if z_data and (z_data.get('z_experiment') is not None or z_data.get('z_analysis') is not None):
                    self._perform_reanalysis_z(obj_id, name, obj)

            for exp_name in self.post_reanalysis_experiments:
                log('Running experiment {} on object {}'.format(exp_name, obj_id, obj=obj))

                self._run_experiment(obj_id, exp_name, stage="_post", name=name, obj=obj)

            log("Finished capturing object {}".format(obj_id))
            # Clearing the experiments from the view for resources saving
            Zen.Application.Documents.RemoveAll()

    def _perform_reanalysis_xy(self, obj_id, name=None, obj=None):
        """
        Function responsible for initializing Python xy reanalysis on object from object_visualization experiment result and
        reading the new-corrected positions of object.
        """
        log('Initialized reanalysis of object {}'.format(obj_id))

        file_name = self.path_manager.result_path(obj_id, '_exp', self.object_visualization_experiment, name)
        saving_path = self.path_manager.temp_file_path(obj_id, 'xy', name)

        args_xy = {'type': 'overview', 'file_path': file_name,
                   'saving_path': saving_path, 'analysis_arguments': self.reanalysis_dict['xy'], 'is_FCS': False}

        log("Running XY reanalysis script with args: {}".format(args_xy))
        self.python_analysis_runner.run(**args_xy)

        new_data = self.load_measurements(obj_id, reanalysis_type="xy", name=name)

        if not new_data:
            log("Warning: No XY reanalysis points found for object {}".format(obj_id))
            return

        new_position = new_data[list(new_data.keys())[0]]['position']

        ZeissApiProcessor.move(new_position)
        log("Moved stage to XY reanalysis position for object {}".format(obj_id))

    def _perform_reanalysis_z(self, obj_id, name=None, obj=None):
        """
        Function responsible for executing the z-reanalysis experiments, initializing the Python analysis and reading
        the JSON with new positions
        """

        z_cfg = self.reanalysis_dict['z']

        z_exp = z_cfg['z_experiment']
        z_analysis = z_cfg['z_analysis']

        self._run_experiment(obj_id, z_exp, stage="_reanalysis_z", name=name, obj=obj)

        file_name = self.path_manager.result_path(obj_id, "_reanalysis_z", z_exp, name)
        saving_path = self.path_manager.temp_file_path(obj_id, 'z', name)

        args_z = {'type': 'reanalysis_z', 'file_path': file_name, 'saving_path': saving_path,
                  'analysis_arguments': z_analysis, 'is_FCS': z_cfg['is_FCS']}

        log("Running Z reanalysis script with args: {}".format(args_z))
        self.python_analysis_runner.run(**args_z)

        z_data = self.load_measurements(obj_id, reanalysis_type="z", name=name)

        new_positions = z_data[list(z_data.keys())[0]]['position']

        ZeissApiProcessor.move(new_positions)

        log("Moved stage to Z reanalysis position for object {}".format(obj_id))

        log("Finished reanalysis for object {}".format(obj_id))

    def _run_experiment(self, obj_id, exp_item, stage, name=None, obj=None):
        """
        Function responsible for loading, executing experiments and saving the results in correct directory with
        proper name. It also initializes the adaptive experiment: changes the chosen experiment whenever it is being
        called by the user specified function, takes as arguments the experiments and object properties.
        """

        if self.adaptive_experiment is not None:

            adaptive_experiment = eval(self.adaptive_experiment)

            if adaptive_experiment['experiment'] == exp_item:
                log('Doing adaptive experiment {}'.format(adaptive_experiment))

                fun = adaptive_experiment['function']

                fun(exp_item, obj_id, stage, obj, name)

                log('Modified z experiment with {}'.format(adaptive_experiment))

        ZeissApiProcessor.load_experiment(exp_item)
        ZeissApiProcessor.execute_current_experiment()

        # Different approaches for saving for .fcs files (which gives None) and .czi files
        if Zen.Application.Documents.ActiveDocument is None:

            file_name = self.path_manager.result_dir(obj_id, stage, name)
            base_name = Path.GetFileNameWithoutExtension(self.path_manager.result_path(obj_id, stage, exp_item, name))

        else:
            file_name = self.path_manager.result_path(obj_id, stage, exp_item, name)
            base_name = None

        ZeissApiProcessor.save_experiment_result(file_name, base_name)

        log("Saved the result: {}".format(file_name))


################################## Functions for adaptive experiments: #######################################

def fcs_zscan(exp_item, obj_id, stage, obj, name):
    """
    Example of the function suited for adaptive experiments. Based on the radius of the object it moves from the focus
    by the object radius and set this as the center of z-scan with FCS, useful for finding the top of GUVs when combined
    when the experiment is chosen for the z-reanalysis.
    """
    radius = obj['radius']

    if radius > 200:
        radius = 0

    actual_position = ZeissApiProcessor.get_stage_focus_position()
    log("I could have move by radius of {}".format(str(obj)))

    modified_position = [actual_position[0], actual_position[1], actual_position[2] + radius]

    exp_obj = Zen.Acquisition.Experiments.GetByName(exp_item)

    exp_obj.ClearExperimentRegionsAndPositions(0)
    exp_obj.ClearTileRegionsAndPositions(0)

    z_offset = [modified_position[2] - 0.2, modified_position[2] - 0.1, modified_position[2],
                modified_position[2] + 0.1, modified_position[2] + 0.2]

    positions_dict = {}

    for i in range(len(z_offset)):
        name_for_dict = "P{}".format(i + 1)

        positions_dict[name_for_dict] = {'x': modified_position[0], 'y': modified_position[1], 'z': z_offset[i]}

    path_menager = PathManager(CONFIG_PATH)

    res_dir = path_menager.result_dir(obj_id, stage, name)

    # At this point one needs to save the positions of the FCS measurements, because there is no information about the
    # positions in the metadata
    path = Path.Combine(res_dir, "FCS_points.json")

    with open(path, "w") as file:
        json.dump(positions_dict, file, indent=2, ensure_ascii=False)

    for z_position in z_offset:
        exp_obj.AddSinglePosition(blockIndex=0, x=modified_position[0], y=modified_position[1], z=z_position)

    exp_obj.SetActive()


################################## Code for generating GUI #######################################


with open(PROCESSING_PATH, 'r') as file:
    preprocessing_data = json.load(file)


def getshortfiles(filelist):
    """
    Gives the name of the files, without theirs extension.
    :param filelist: list of the file names
    :return: list of the same file names but without extension
    """
    files_short = []
    for short in filelist:
        files_short.append(Path.GetFileNameWithoutExtension(short))

    return files_short

# Finding the names of the user saved experiments .czexp
docfolder = Zen.Application.Environment.GetFolderPath(ZenSpecialFolder.UserDocuments)
expfiles = Directory.GetFiles(Path.Combine(docfolder, 'Experiment Setups'), '*.czexp')
experiments = getshortfiles(expfiles)

# === window 1: choosing work modes ===
window = ZenWindow()
window.Initialize("Automated Acquisition")
window.Title = "Automated Acquisition"

window.AddCheckbox('finding_objects_mode', 'Finding objects mode:', True)
window.AddCheckbox('multiple_overiews', 'Multiple overviews mode:', True)

result_mode = window.Show()
finding_objects = result_mode.GetValue('finding_objects_mode')
multiple_overviews = result_mode.GetValue('multiple_overiews')

if result_mode.HasCanceled:
    raise SystemExit

# === window 2: choosing experiments and analysis, the analysis arguments are specified in the preprocessing_config===
window.ClearContent()
window.Initialize("Automated Acquisition")

if finding_objects:
    window.AddDropDown('over_exp_name', 'Choose overview experiment:', experiments, 0)
    window.AddDropDown('over_analysis', 'Choose overview analysis:', preprocessing_data.keys(), 0)
    window.AddDropDown('vis_exp', 'Choose experiment for object visualization:', experiments, 0)
    window.AddDropDown('rean_xy_name', 'Choose reanalysis in xy:', ["None"] + preprocessing_data.keys(), 0)

window.AddDropDown('z_exp_name', 'Choose experiment for z-reanalysis:', ["None"] + experiments, 0)
window.AddDropDown('z_analysis', 'Choose z-reanalysis:', ["None"] + preprocessing_data.keys(), 0)
window.AddCheckbox('is_FCS', 'Is z analysis experiment a FCS experiments:', True)

default_adaptive = 'None'
window.AddTextBox('adaptive_experiment', 'Adaptive experiment:', default_adaptive)

result_setup = window.Show()

if result_setup.HasCanceled:
    raise SystemExit

# === window 3: choosing post-analysis experiments ===
selected_experiments = []
done = False

while not done:
    window = ZenWindow()
    window.Initialize("Select post-analysis experiments")

    window.AddDropDown('post_exp_name', 'Choose post analysis experiment:', experiments, 0)
    chosen_text = "\n".join(selected_experiments) if selected_experiments else "None yet"
    window.AddMultiLineTextBox('chosen_post_exps', 'Currently selected:', chosen_text)
    window.AddDropDown('action', 'What next?', ['Add another', 'Done', 'Clear all'], 0)

    result_post = window.Show()
    if not result_post:
        break  # user clicked Cancel (X)

    action = result_post.GetValue('action')
    new_exp = result_post.GetValue('post_exp_name')

    if result_post.HasCanceled:
        done = True
        raise SystemExit

    if action == 'Add another':
        if new_exp not in selected_experiments:
            selected_experiments.append(new_exp)
    elif action == 'Clear all':
        selected_experiments = []
    elif action == 'Done':
        if new_exp not in selected_experiments:
            selected_experiments.append(new_exp)
        done = True

# === window 4: Summarry for user===
window = ZenWindow()
window.Initialize("Summary of selections")

summary_text = ""
summary_text += "Finding objects mode: {}\n".format("Enabled" if finding_objects else "Disabled")
summary_text += "Multiple overviews mode: {}\n".format("Enabled" if multiple_overviews else "Disabled")

if finding_objects:
    summary_text += "\nOverview experiment: {}\n".format(result_setup.GetValue('over_exp_name'))
    summar_text = "\nObject visualization experiments: {}\n".format(result_setup.GetValue('vis_exp'))
    summary_text += "Overview analysis: {}\n".format(result_setup.GetValue('over_analysis'))
    summary_text += "Reanalysis XY: {}\n".format(result_setup.GetValue('rean_xy_name'))
    summary_text += "Z experiment: {}\n".format(result_setup.GetValue('z_exp_name'))
    summary_text += "Z analysis: {}\n".format(result_setup.GetValue('z_analysis'))
    summary_text += "Is z experiment a FCS?: {}\n".format(result_setup.GetValue('is_FCS'))
else:
    summary_text += "\nZ experiment: {}\n".format(result_setup.GetValue('z_exp_name'))
    summary_text += "Z analysis: {}\n".format(result_setup.GetValue('z_analysis'))

if selected_experiments:
    summary_text += "\nPost-analysis experiments:\n" + "\n".join(selected_experiments)
else:
    summary_text += "\nNo post-analysis experiments selected."

window.AddMultiLineTextBox('summary_box', 'Summary:', summary_text)
window.Show()


################################## Actual Macro: initializing the AcquisitionPipeline with arguments from the GUI #######################################

def none_or_value(x):
    return None if x == "None" else x


finding_objects = result_mode.GetValue('finding_objects_mode')
multiple_overviews = result_mode.GetValue('multiple_overiews')

if finding_objects:

    pipeline = AcquisitionPipeline(object_visualization_experiment=result_setup.GetValue('vis_exp'),
                                   reanalysis_dict={'xy': none_or_value(result_setup.GetValue('over_analysis')),
                                                    'z': {'z_experiment': none_or_value(
                                                        result_setup.GetValue('z_exp_name')),
                                                          'z_analysis': none_or_value(
                                                              result_setup.GetValue('z_analysis')),
                                                          'is_FCS': result_setup.GetValue('is_FCS')}},
                                   post_reanalysis_experiments=selected_experiments,
                                   adaptive_experiment=none_or_value(result_setup.GetValue('adaptive_experiment'))
                                   )

    if multiple_overviews:
        for point in pipeline.points_for_overview:
            ZeissApiProcessor.move(point['position'])

            pipeline.acquire_overview(overview_experiment=result_setup.GetValue('over_exp_name'),
                                      analysis_args=result_setup.GetValue('over_analysis'), name=point['name'])
            pipeline.capture_objects(name=point['name'])

    else:
        pipeline.acquire_overview(overview_experiment=result_setup.GetValue('over_exp_name'),
                                  analysis_args=result_setup.GetValue('over_analysis'), name=None)
        pipeline.capture_objects(name=None)

else:
    pipeline = AcquisitionPipeline(
        reanalysis_dict={'z': {'z_experiment': none_or_value(result_setup.GetValue('z_exp_name')),
                               'z_analysis': none_or_value(result_setup.GetValue('z_analysis')),
                               'is_FCS': result_setup.GetValue('is_FCS')}},
    )
    if multiple_overviews:

        for point in pipeline.points_for_overview:

            ZeissApiProcessor.move(point['position'])

            pipeline._perform_reanalysis_z(obj_id=pipeline.overview_id, name=point['name'])

            for experiment in selected_experiments:
                pipeline._run_experiment(obj_id=pipeline.overview_id, exp_item=experiment, stage='_post',
                                         name=point['name'], obj=None)

            Zen.Appplication.Documents.RemoveAll()

    else:

        pipeline._perform_reanalysis_z(obj_id=pipeline.overview_id)

        for experiment in selected_experiments:
            pipeline._run_experiment(obj_id=pipeline.overview_id, exp_item=experiment, stage='_post')

        Zen.Appplication.Documents.RemoveAll()  #

</Text>
  <Author></Author>
  <Description></Description>
  <Keywords></Keywords>
  <Row>80</Row>
  <Column>12</Column>
</Script>
