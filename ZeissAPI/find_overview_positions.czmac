<?xml version="1.0" encoding="utf-8"?>
<Script>
  <Context>Zen26</Context>
  <Version>1.0</Version>
  <Language>Python</Language>
  <Text>
import json
from System.IO import Directory, Path, File
from execute_python import log


def get_stage_focus_position():
    """
    API call for obtaining the current position of the stage
    :return: list of the x,y,z coordinates of the stage position
    """
    x = Zen.Devices.Stage.ActualPositionX
    y = Zen.Devices.Stage.ActualPositionY
    z = Zen.Devices.Focus.ActualPosition

    return [x, y, z]


class AcquisitionGrid:
    """
    Class for the fast generation of the points on which one will perform the full pipeline
    of automated processes
    """

    CONFIG_PATH = r"D:\zeiss\Desktop\automation\config\path_config.json"

    def __init__(
            self,

            # 'available modes are: experiment' or 'manual', experiment mode reads the points from the centers of the tiles, manual generates the points by
            # specifying the shifts in x, y and start/end position).
            mode="experiment",

            experiment_name="AI_sample_finder",  # works in experiment mode: name of the .czexp file to read points from
            manual_points=None
            # dictionairy with the keys: "start", "end", "shift_x", "shift_y", "start_position", where start and end are in the convention of the plate,
            # while start_position is a real stage position in um of the start.
            # For example start=A1, end=C4. The grid is then generated where A1 is the top-left corner and C4 is bottom right. The distances between wells are calculated
            # from the shifts and starting_position
    ):
        self.experiment_name = experiment_name
        self.mode = mode
        self.manual_points = manual_points or []

        self.config = self.read_json(self.CONFIG_PATH)
        self.measuring_points_path = self.config[
            "measuring_points_path"]  # required for savings points in the directory compatible with automation pipeline

        # Choosing the method suitable mode of the points generation
        if self.mode == "experiment":
            self.points_for_overview = self.calculate_points_for_overview()
        elif self.mode == "manual":
            self.points_for_overview = self.generate_grid_from_args()
        else:
            raise ValueError("Unknown mode: {}".format(self.mode))

    @staticmethod
    def read_json(path):
        with open(path, "r") as file:
            return json.load(file)

    def calculate_points_for_overview(self):
        """
        Reads the centers of the tiles from the .czexp file name
        return:
        list[dict]: List of points with keys:
            - "name": grid label (e.g. "A1")
            - "position": [x, y, z] coordinates
        """
        exp = Zen.Acquisition.Experiments.GetByName(self.experiment_name)
        tile_region_objects = exp.GetTileRegionInfos(0)

        points_for_overview = []
        for tile in tile_region_objects:
            points_for_overview.append({
                "position": [tile.CenterX, tile.CenterY, tile.Z],
                "name": tile.Name,
            })
        return points_for_overview

    def generate_grid_from_args(self):
        """
        Generates a regular grid of 3D points based on manual configuration.
        The grid is defined using plate-like labels (e.g. A1 to C3),
        a starting position in 3D space, and constant shifts in X and Y
        directions. Each generated point has a unique name (e.g. "B2")
        and a fixed Z coordinate taken from the start position.

        return: list[dict]: List of points with keys:
                - "name": grid label (e.g. "A1")
                - "position": [x, y, z] coordinates
        """

        cfg = self.manual_points

        required = ["start", "end", "shift_x", "shift_y", "start_position"]
        for r in required:
            if r not in cfg:
                raise ValueError("Missing '{}' in manual_points".format(r))

        start_label = cfg["start"].upper()
        end_label = cfg["end"].upper()

        # conversion from example: "A1" -&gt; ('A', 1)
        start_col, start_row = start_label[0], int(start_label[1:])
        end_col, end_row = end_label[0], int(end_label[1:])

        cols = [chr(c) for c in range(ord(start_col), ord(end_col) + 1)]
        rows = list(range(start_row, end_row + 1))

        shift_x = cfg["shift_x"]
        shift_y = cfg["shift_y"]
        base_x, base_y, base_z = cfg["start_position"]

        points = []
        for c_idx, col in enumerate(cols):
            for r_idx, row in enumerate(rows):
                x = base_x + r_idx * shift_x
                y = base_y + c_idx * shift_y
                z = base_z
                name = "{}{}".format(col, row)
                points.append({
                    "name": name,
                    "position": [x, y, z]
                })
        log("Generated {} manual grid points.".format(len(points)))
        return points

    def save_overview_points(self):
        file_name = "points_for_overview.json"
        saving_path = Path.Combine(self.measuring_points_path, file_name)
        with open(saving_path, "w") as file:
            json.dump(self.points_for_overview, file, indent=2)


############################ GUI generation ##############################################################################
def getshortfiles(filelist):
    """
    Gives the name of the files, without theirs extension.
    :param filelist: list of the file names
    :return: list of the same file names but without extension
    """
    files_short = []
    for short in filelist:
        files_short.append(Path.GetFileNameWithoutExtension(short))

    return files_short


# Getting the names of the availables .czexp files
docfolder = Zen.Application.Environment.GetFolderPath(ZenSpecialFolder.UserDocuments)
expfiles = Directory.GetFiles(Path.Combine(docfolder, 'Experiment Setups'), '*.czexp')
experiments = getshortfiles(expfiles)

window = ZenWindow()
window.Initialize("Create grid for automated acquisition")
window.Title = "Grig for automated acquisition"
window.AddCheckbox('reading_mode', 'Do you want to read data points from experiments?', False)

result_mode = window.Show()

if result_mode.HasCanceled:
    raise SystemExit

window.ClearContent()
window.Initialize("Parameters")

if result_mode.GetValue("reading_mode"):

    window.AddDropDown('exp_name', 'Experiments with tiles:', experiments, 0)

else:

    window.AddIntegerRange('shift_x', 'Shift in x [um]:', 1500, 20, 20000)
    window.AddIntegerRange('shift_y', 'Shift in y [um]:', 1500, 20, 20000)
    window.AddTextBox('start_point', 'Starting well:', 'A1')
    window.AddTextBox('end_point', 'Starting well:', 'B2')

result_parameters = window.Show()

if result_mode.HasCanceled:
    raise SystemExit

############################ Initialization of the code above ##############################################################################

if result_mode.GetValue("reading_mode"):

    chosen_mode = "experiment"
    chosen_manual_points = None
    chosen_experiment = result_parameters.GetValue('exp_name')

else:

    chosen_mode = "manual"
    chosen_manual_points = {"start": result_parameters.GetValue("start_point"),
                            "end": result_parameters.GetValue("end_point"),
                            "shift_x": result_parameters.GetValue("shift_x"),
                            "shift_y": result_parameters.GetValue("shift_y"), "start_position":
                                get_stage_focus_position()}
    chosen_experiment = None

grid_manual = AcquisitionGrid(mode=chosen_mode, experiment_name=chosen_experiment, manual_points=chosen_manual_points)
grid_manual.save_overview_points()

</Text>
  <Author></Author>
  <Description></Description>
  <Keywords></Keywords>
  <Row>80</Row>
  <Column>12</Column>
</Script>
